# Regex    --模糊匹配 python的re模块

字符匹配
- str    --完全匹配
	- find("")
	- replace("old","new")
	- split()
----
## 元字符    --贪婪匹配，默认最大匹配. 在数量限定元字符后面加 ？ 可以变成最小匹配
'.'     = 1 默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行
'^'     匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r"^a","\nabc\neee",flags=re.MULTILINE)
'$$'     匹配字符结尾，或e.search("foo$","bfoo\nsdfsf",flags=re.MULTILINE).group()也可以
'*'     >= 0匹配*号前的字符0次或多次，re.findall("ab*","cabb3abcbbac")  结果为['abb', 'ab', 'a']
'+'     >= 1匹配前一个字符1次或多次，re.findall("ab+","ab+cd+abb+bba") 结果['ab', 'abb']
'?'     <= 1匹配前一个字符1次或0次
'{m}'   匹配前一个字符m次
'{n,m}' 匹配前一个字符n到m次，re.findall("ab{1,3}","abb abc abbcbbb") 结果'abb', 'ab', 'abb']
'|'     匹配|左或|右的字符，re.search("abc|ABC","ABCBabcCD").group() 结果'ABC'
'(...)' 分组匹配配合数量限定，re.search("(abc){2}a(123|456)c", "abcabca456c").group() 结果 abcabca456c
'[]'    字符集限定单值匹配， 所有元素取非[^]，范围[a-z], \ 仍然有用。用[,] 多个组合或关系；==> 取消元字符特殊功能


'\'       元字符 <--> 普通字符 ；转义 ； 单值 ;
	'\A'    ^ 只从字符开头匹配，re.search("\Aabc","alexabc") 是匹配不到的
	'\Z'    匹配字符结尾，同$
	'\b'    单词与特殊字符[$,space]等的特殊边界 "I am list"  => 第一个I ："I\b"
	'\d'    匹配数字0-9
	'\D'    匹配非数字
	'\w'    !匹配[A-Za-z0-9] 字母+数字
	'\W'    !匹配非[A-Za-z0-9]
	'\s'    !匹配任意空白字符 [\t\n\r\f\v]
	'\S'    !匹配任意非空字符
's'       !匹配空白字符、\t、\n、\r , re.search("\s+","ab\tc1\n3").group() 结果 '\t'
'r'       
	r'\\'       等价于'\\\\'  => 匹配字符串中的 单\
	r'\bblow'   匹配 “blow”   => 我们写的是传递到re模块的字符串，需要考虑到Cpython会先处理
	原因：代码 ->   python interpretor   -> regex inter   : 两次传递 ；
									\  有特殊含义\\或r       \ 也特殊    =>  \\\\

'(?P<name>...)' 分组匹配 result = re.search("(?P<province>[0-9]{4})(?P<city>[0-9]{2})(?P<birthday>[0-9]{4})","371481199306143242")
												 result.groupdict("city") == > "81"
												 结果{'province': '3714', 'city': '81', 'birthday': '1993'}

----
## 方法    ==> 对象里的值需要用group()取出，分组如上groupdict("key")
静态的，直接re.xxx  调用
- findall("patt","tar_str")    --patt为具体字符串时 = str.find("patt"，)返回一个列表
- finditer()      --返回一个可迭代对象
- search("patt","tar_str")    --返回一个对象，匹配第一个满足条件的结果
	- 取出值 = > re.search().group()
	- search("(?P<varname1>patt1)patt(?P<varname2>patt2)","tar_str")    --每个组patt匹配的结果赋值给相应变量
		- 取出re.search().group("varname")
- match("patt","")    --pattern 不需要//包围，从首字符开始匹配，返回一个对象，group()取出匹配到的内容
- split(,)    --可以自定义划分的字符，可多个[,]，返回一个对象。
- sub("patt","new","tar_str")    --替换字符串，返回一个对象
- subn()    --多一个替换次数的值
- compile()    --将自定义的正则表达式做为参数创建一个re对象，后续使用函数时可以缺省匹配模式并重复使用
	myre = re.compile("myregex")
	myre.findall("tar_str")
	myre.search("tar_str")

----
## 常用正则
1.由数字、26个英文字母或者下划线组成的字符串:
    ^[0-9a-zA-Z_]{1,}$
2.非负整数（正整数 + 0 ）:
    ^/d+$
3.正整数:
    ^[0-9]*[1-9][0-9]*$
4.非正整数（负整数 + 0）：
    ^((-/d+)|(0+))$
5.负整数 :
    ^-[0-9]*[1-9][0-9]*$
6.整数:    
    ^-?/d+$
7.非负浮点数（正浮点数 + 0）:
    ^/d+(/./d+)?$
8.正浮点数 :
    ^(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*))$
9.非正浮点数（负浮点数 + 0）:
    ^((-/d+(/./d+)?)|(0+(/.0+)?))$
10.负浮点数 :
    ^(-(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*)))$
11.浮点数 :
    ^(-?/d+)(/./d+)?$
12.由26个英文字母组成的字符串 :    
    ^[A-Za-z]+$
13.由26个英文字母的大写组成的字符串 :
    ^[A-Z]+$
14.由26个英文字母的小写组成的字符串 :
    ^[a-z]+$
15.由数字和26个英文字母组成的字符串 :
    ^[A-Za-z0-9]+$
16.由数字、26个英文字母或者下划线组成的字符串 :    
    ^/w+$
17.email地址 :
    ^[/w-]+(/.[/w-]+)*@[/w-]+(/.[/w-]+)+$
18.url:    
    ^[a-zA-z]+://(/w+(-/w+)*)(/.(/w+(-/w+)*))*(/?/S*)?$
19.年-月-日:
    /^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/
20.月/日/年:
    /^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/
21.Emil:
    ^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$
22.电话号码:
    (d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?
23.IP地址:
    ^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$
24.匹配中文字符的正则表达式：
    [/u4e00-/u9fa5]
25.匹配双字节字符(包括汉字在内)：
    [^/x00-/xff]
26.匹配空行的正则表达式：
    /n[/s| ]*/r
27.匹配HTML标记的正则表达式：
    /<(.*)>.*<///1>|<(.*) //>/
28.匹配首尾空格的正则表达式：
    (^/s*)|(/s*$)
29.匹配Email地址的正则表达式：
    /w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*
30.匹配网址URL的正则表达式：
    ^[a-zA-z]+://(//w+(-//w+)*)(//.(//w+(-//w+)*))*(//?//S*)?$
31.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：
    ^[a-zA-Z][a-zA-Z0-9_]{4,15}$
32.匹配国内电话号码：
    (/d{3}-|/d{4}-)?(/d{8}|/d{7})?
33.匹配腾讯QQ号：
    ^[1-9]*[1-9][0-9]*$
34.只能输入数字：
    ^[0-9]*$
35.只能输入n位的数字：
    ^/d{n}$
36.只能输入至少n位的数字：
    ^/d{n,}$
37.只能输入m~n位的数字：
    ^/d{m,n}$
38.只能输入零和非零开头的数字：
    ^(0|[1-9][0-9]*)$
39.只能输入有两位小数的正实数：
    ^[0-9]+(.[0-9]{2})?$
40.只能输入有1~3位小数的正实数：
    ^[0-9]+(.[0-9]{1,3})?$
41.只能输入非零的正整数：
    ^/+?[1-9][0-9]*$
42.只能输入非零的负整数：
    ^/-[1-9][0-9]*$
43.只能输入长度为3的字符：
    ^.{3}$
44.只能输入由26个英文字母组成的字符串：
    ^[A-Za-z]+$
45.只能输入由26个大写英文字母组成的字符串：
    ^[A-Z]+$
46.只能输入由26个小写英文字母组成的字符串：
    ^[a-z]+$
47.只能输入由数字和26个英文字母组成的字符串：
    ^[A-Za-z0-9]+$
48.只能输入由数字和26个英文字母或者下划线组成的字符串：
    ^/w+$
49.验证用户密码(正确格式为： 以字母开头，长度在5~17 之间，只能包含字符、数字和下划线)
    ^[a-zA-Z]/w{5,17}$
50.验证是否包含有 ^%&',;=?$/"等字符：
    [^%&',;=?$/x22]+
51.只能输入汉字：
    ^[\u4e00-\u9fa5]{0,}$
53、只含有汉字、数字、字母、下划线，下划线位置不限
    ^[a-zA-Z0-9_\u4e00-\u9fa5]+$
54、2~4个汉字
    @"^[\u4E00-\u9FA5]{2,4}$
55、身份证号码
		reg_18 = r"^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$"
		reg_15 = r"^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}$"
