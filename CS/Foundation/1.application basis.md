> 表示、轉換 和 執行控制流
## 馮諾依曼結構
> 存儲程序，將需要計算機完成的工作，事先編寫成程序和原始數據並送入貯存並啓動執行；一旦啓動執行，則計算機應能在不需要操作人員干預下，自動完成逐條取出和執行指令的任務

第一台通用電子計算機ENIAC誕生于1946年在賓夕法尼亞大學，由電子真空管組成；内部十進制
ENIAC: Electrical Numerical Integerator And Computer

### 存儲程序通用電子計算
> EDVAC: Electrical Discrete Variable Automatic Computer

- 普林斯頓高等研究院-IAS計算機，報告中稱其計算機結構為馮諾依曼機構
- 組成: 主存儲器、取指令組件(控制器)、執行指令組件(運算器)、輸入程序和原始數據的組件(I)、輸出結果的組件(O)
- 早期組件分散，現在總綫方式
- 指令和數據形式上沒有區別，但計算器能區分
- 内部用二進制表示指令和數據
- 存儲程序的工作方式

### 現代計算機結構
> 馮諾依曼結構基礎，指令譯碼成控制信號
- CPU: 控制器  + 運算器 + 寄存器
- 總綫: 地址總綫、數據總綫、控制總綫
- 存儲器
$$
主机 \uparrow
$$
- 輸入設備/輸出設備(IO總綫)
    1. USB控制器：鼠標、鍵盤
    2. 顯示適配器：顯示器
    3. 磁盤控制器：磁盤

```REMARK
CPU:中央處理器
PC:程序計數器
MAR:存儲器地址寄存器
MDR:存儲器數據寄存器
ALU:算術邏輯部件
IR:指令寄存器
GPRs:通用寄存器組

指令操作：
    操作碼 + 操作數
        源操作數：立即數、寄存器、存儲器
    結果：寄存器、存儲器
```

## 編程語言

### 發展歷史
1. 機器語言 - 二進制
2. 匯編語言 - 符號              >>> 描述細節過多、無法跨平臺
3. 高級語言
   1. 編譯：高級語言源程序轉換爲機器級目標程序，執行時只要啓動目標程序即可
   2. 解釋：解釋程序將高級語言逐行翻譯成機器指令並立即執行，不生成目標文件

### C語言轉換處理
> 1. 語言處理程序 + 語言運行時系統 -> 語言處理系統
> 2. 人機接口 + 操作系統内核(指令集體系結構 + 計算機硬件) -> 操作系統
> 3. 應用程序 -> 語言處理系統 -> 操作系統 -> 指令集體系結構 -> 計算機硬件

1. .c 源文本文件
    | 预处理器
2. .i 预处理文本文件
    | 编译器 cc1
3. .s 汇编語言源文本文件
    | 汇编器 as
4. .o 可重定位二进制机器语言目标应用程序
    | 链接器 ld
5. executable 可之行目标二进制程序
    | os
6. 系统调用api
    | os内核
7. 指令集体系结构
    | 机器指令
8. 控制信号
    | 硬件
9. 电路、器件、电位


### 整體層次結構
> 抽象和實現
1. 應用程序
2. 算法 - 結構化數據描述
3. 編程語言
4. 操作系統/虛擬機
5. 指令集體系結構ISA - 軟硬件交界接口規約 Instruction Set Architecture
6. 微體系結構 - ARM、MIPS、IA-32
7. 功能部件 - ALU、CPU、Register
8. 電路 - 邏輯門
9. 器件 - 位信息、晶體管

## 數據表示

### 數據分類
1. 數值數據：整數(帶/無符號)、浮點數(實數)
2. 非數值數據：邏輯數(包括位串)、字符

### 表示三要素
1. 确定进制：十、二、八、十六进制; 八、十六进制便于阅读和书写
   1. 11B
   2. 11O
   3. 11H   ox11
2. 确定定点数还是浮点数表示(小数点问题, 存储类型)
   1. 定点整数、定点小数
   2. 浮点数：定点小数 + 定点整数来表示
3. 确定定点数的编码(正负号问题)：原码、反码、补码、移码

### 數制和編碼

#### 编码
> 真值 -> 机器数, 原码、反码、补码、移码
现实中的数字 -->> 二进制
1. 原码：0为正，1为负，数值部分为绝对值的二进制
2. 反码：正数的反码同原码；负数的反码为符号位外的位取反
3. 补码：正数的补码同原码、反码；负数的补码为反码末位加1，支持逆运算
   1. 模n运算或同余运算系统： A = A mod n；其中数字超过一定值后（称为模/余数）后会“卷回”到较小的数
   2. x补码 = 2^n + x；即原码加高一位的值直接得到，整数会溢出保持原样；1 0000 0000 - 0111 1011 = 1111 1111 - 01111 1011 + 1 -> 即取反 + 1，也即从右到左第一个1之前除符号位之外的各位取反
   3. 0唯一编码，比原码多表示一个最小负数
4. 变形(4s)补码：2^n + x 可能溢出的中间结果；4s为双符号位2^2
```C
// 模12时钟系统：10 - 4 = 6； 10 + 8 = 18 --> 10 - 4 = 10 + 8 --> -4 = 8；8 是 -4 对模12 的补码
//  结论1：负数的补码 = 模 - 该负数的绝对值
//  结论2：对于确定的模，a - 小于模的b = a + b的补码，可能的溢出位丢弃(模运算)则实现了加法代替减法，使加减运算统一
//EXAMPLE 4位十进制数 模 10^4运算系统
9828 - 1928 = 9828 + (10^4 - 1928)2**
            = 9828 + 8072
            = 17900
            = 17900 mod 10^4            // 一个数 与 其
            = 7900
```

1. 移码：补码首位加1，即首位取反

#### 二進制編碼原因
1. 製造擁有兩個穩定態的物理器件比較容易(電位的高/低, 脉冲有/无, 正/负极)
2. 二进制编码、计数、运算规则简单
3. 与逻辑命题真/假对应，便于逻辑运算
4. 因此方便使用逻辑电路实现算数运算


#### 进制转换
1. R进制 -> 十进制：按权展开
    10101.01B = 1 * 2^4 + 1 * 2^2 + 1 * 2^0 + 1 * 2^(-2) = 21.25D

2. 十进制 -> R进制
   1. 整数部分：除R取余，高位在下
   2. 小数部分：乘R取整，高位在上；可能永远无法得到0，最终只能得到某个有效位数的近似值


### 定点数
> 约定小数点位置固定； 整数采用补码表示、浮点数的尾数使用原码定点小数
1. 原码：0为正、1为负数, 数值部分不变
   1. 0的表示不唯一
   2. 加减运算方式不统一 - 绝对值相关
   3. 需要额外对符号位处理，不利于硬件设计
2. 补码：2^n + x
3. 移码：补码加上偏置常数(bias/Excess)
   1.  当编码位数为n时，bias取 2^(n-1) 或 2^(n-1) - 1
   2.  当 bias 为 2^(n-1) 时，即首位加1，移码和补码
   3.  表示浮点数的阶或指数，便于对阶操作时比较大小；两边同时加偏置常数
```c
// Example
x = -8 = 0 1000B
bias = 2^(4-1) = 0 1000B
xBiased = -8 + 8 = 0 = 0000B
```

#### c中的整数
> 无符号 / 带符号整数
```c
// 机器中字的位排列方式：高位从左到右 和 高位从右到左；描述左右时有歧义
// LSB - Least Significant Bit 表示最低有效位；MSB 表示最高有效位
// 1. 无符号整数无符号位
unsigned int (shor/long)
// 2. 带符号为MSB为符号位
int (shor/long)
// 带符号数比较先看符号位再看剩余位；无符号为直接看整体补码
// 逻辑运算时 带强制类型则按强制类型比较，否则统一为无符号数比较 Integer Promotion
-1 < 0U  => false；按无符号数比较，-1的补码为最大的无符号数翻转
214748367U > -214748367 - 1 => false；按无符号数比较，最小负数再减1则编码同无符号数最大值
214748367 > (int)214748367U  => trur；按带符号数int比较，后面的214748367U无符号整数首位为1，按带符号数比较时为负数
```
#### c中的定点小数
```c
typedef int fixed_point; // 使用int类型表示32位固定点数

#define FRACTIONAL_BITS 16 // 定义小数部分的位数

// 将浮点数转换为32位固定点数
fixed_point float_to_fixed(float num) {
    return (fixed_point)(num * (1 << FRACTIONAL_BITS));
}

// 将32位固定点数转换为浮点数
float fixed_to_float(fixed_point num) {
    return (float)num / (1 << FRACTIONAL_BITS);
}

```


### 浮点数 f = (-1)^S * M + R^E
> 只有 0 / 1, 故只能约定小数点的位置来表示. 即小数点实际并不存在于计算机中
1. 定点整数表示整数部分，带符号/无符号
2. 定点小数表示尾数部分 - 原码
3. 移码表示阶或指数，避免两个符号位：浮点数自身和指数部分。移码即首位加1整体成为无符号整数
```c
/**
f = (-1)^S * M + R^E
类似科学计数法
S: sign 0/1 决定符号
M: mantissa二进制定点小数，称为x的尾数
E: exponent 浮点数的阶或指数，为移码
R: radix 进制基数，现代计算机中为2

>>> 二进制存储:   | S |    E     |                 m                  |
另外规格化后的尾数第一位总数1，故规定第一位的1不明显表示出来，可以用23个位数表示24位尾数
32位：偏置常数128； 0 | 1-8 | 9 - 31 |；最后的23位加规格化的固定第一位1合成24位
    最大正数：0.1...24...1 * 2^(11111111) = (1 - 2^(-24)) * 2^(2^8 - 1 - 128) = (1-2^(-24)) * 2^(127)
    最小正数：0.10..24...0 * 2^(00000000) = (1/2) * 2^(0-128) = 2^(-129)
               | 固定的第一位1，且由于原码对称故正负关于原点对称
    最小负数：-(1-2^(-24)) * 2^(127)
    最大负数：-2^(-129)

四个不可表达的区域：负上溢 ........ 负下溢 .... 0 .... 正下溢 ........ 正上溢
机器0： 0 或 下溢区间
浮点数的范围变大了：但是个数没有变
实际编码时尾数是将固定的1作为前缀： 1.x...23...x，比上面的更景区一位
*/
```

#### IEEE 754 Standard
> 规定尾数、和指数的位长；阶码为 2^(n-1) - 1，表述范围更大
- 32位单精度： 1 + 8 + 23 --> 127
$$
E: 0000 0001(-126) - 1111 1110(127)\\
实际值：-1^S + (1 + M) + 2^(E - 127)
$$
- 64位双精度：1 + 11 + 52 --> 1023
$$
实际值：-1^S + (1 + M) + 2^(E - 1023)
$$
```c
// 二进制转十进制小数
BEE00000H
1011 1110 1110 0000 0000 0000 0000 0000 B
1 01111101 11000000000000000000000 B
S = 1
E = 01111101 - 127 = -2         // 是由真值加偏置的移码，求真值需要逆向减回去
M = 1 + 1*2^(-1) + 1*2^(-2) + 0*2^(13) + 0...+...0 = 1.75
result = -1.75 * 2^(-2) = -0.4375
// 十进制小数转IEEE 754编码浮点数
-12.75D
-1100.11B
-1.10011 * 2^3
s = 1
E = 130 = 128 + 2 = 1000 0010
M = 10011 = 1001100000000000000000
result = 1 10000010 1001100000000000000000100110 = C14C0000H
```

#### 规格化数和特殊数
- 规格化数：
    - E：1 - 254
    - M：任意小数点前隐含1
- 特殊数:
    1. 0 => +000000000000 = -000000000000
    2. +x.0/0 = +$\infty => 0 11111111 0000000000000000000000 $
    3. -x.0/0 = -$\infty => 1 11111111 0000000000000000000000 $
    4. 非数NaN，如sqrt(-4.0)，0/0 => 0/1 11111111 [非0尾数]
    5. 非规格化数：0/1 00000000 [非0尾数] => 阶都为-126

```c
// 实际编码的区间边界
0 ... 2^(-126) ... 2^(125) ...... 2^(124) ......... 2^(123)
        | 每个区间有2^(23)个点，越来越稀疏
    | 非规格化数
```


### 非数值数据编码

#### 逻辑数据
> 位：按位存储、按位计算；都是二进制串，计算机通过指令来识别

#### 字符

##### 西文
> 有限字符组合，不超过256个；使用7或8个二进制位表示
```c
// 常用编码位 7位ASCII码 128个字符, 26个英文字符，0xxx xxxx
ASCII-D     ASCII-H     ASCII-O     Chr
32          0X20        040         \space
48          0x30        060         0           >
57          0x39        071         9
65          0x41        0101        A           >
90          0x5A        0132        Z
97          0x61        0141        a           >
122         0x7A        0172        z
```

##### 汉字
> 表意文字，方块图形；数量巨大，总数超过6万字
- 输入码：用相应按键进行编码表示，如拼音
- 内码：系统中进行存储、查找、传送等处理使用的编码（西文也有-ASCII）
- 字模点阵或轮廓描述：用于显示、打印等使用的编码（西文也有）

1. GB2312-80 内码
   1.  三部分组成：
       1.  字母、数字和各种符号，包括英文、俄文、日文平假名与片假名、罗马字母、汉语拼音等共687个
       2.  一级常用汉字，3755个，按汉语拼音排序
       3.  二级常用汉字，3008个，按偏旁部首排列
   2. 汉字的区位码：码表由 94 * 94 行列，行号为区号、列号为位号，各占 7 位（可表示128个 > 94）=> 000 0001 000 0001 => 区号在左、位号在右
   3. 汉字的国标码：由区位码各自的区号、位号加上 32 (0x20) 得到，实际存储占16位，前补充0对齐；实际存储时为与ASCII区分，一般将两个字节的首位置为1
```c
// 大： 区号=20，位号=83
区位码：0010100     1010011
国标码：00110100    01110011
区分ASCII：10110100 11110011
```

##### UTF-8
> ascii的拓展，1 - 4字节浮动长度表示，U+0000到 U+10FFFF
组成： leader byte + trailing bytes
1. leader byte 1的数量
   1. 单字节序列：0 -127 ASCII  => 0...
   2. 两字节序列：194-223       => 110...
   3. 三字节序列：224-239       => 1110
   4. 四字节序列：240-247       => 11110
2. trailing byte：第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)

对UTF-8编码中的任意字节，根据第一位，可判断是否为ASCII字符；根据前二位，可判断该字节是否为一个字符编码的第一个字节；根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。

#### 多媒体数据
> 都为0/1字节序列
1. 图形：用构建图形的直线或曲线的坐标点及控制点的01编码数值数据来描述（点、线）
2. 图像：用构成图像的点(像素)的亮度、颜色和灰度等信息的01编码数值数据来描述
3. 音频：声音的模拟信号采样、量化（二进制编码）获得数字信号数据
4. 视频：随时间变化的图像（一幅为一帧）
5. 音乐信息：对乐谱等的编码描述

## 数据存储
> 高级语言中的数据类型宽度和字长相关

### 数据宽度
- 比特 bit：计算机处理、存储、传输信息的最小单位
- 字节 Byte：二进制信息的基本单位，最小可寻址单位， LSB/MSB
- 字 word：数据或处理信息的的单位，为2字节=16位
  - 字长：指数据通路（CPU内部数据流经的路径及其上的部件，如总线、运算器、通用寄存器的位数）的宽度，不同于字，不同的架构字长不一样，DWORD、QWORD

### 存储容量单位 byte
- KB = 2^10 B
- MB = 2^20 B
- GB = 2^30 B
- TB = 2^40 B
- PB = 2^50 B


### 通信带宽单位 bit
- kb/s = 10^3 b/s
- Mb/s = 10^6 b/s
- Gb/s = 10^9 b/s
- Tb/s = 10^12 b/s


### C中的数据类型宽度
```c
            32位    64位
char         1       1
short int    2       2
int          4       4
long int     4       8
char *       4       8
float        4       4
double       8       8

// 其中 float 和 double 是 IEEE754标准规定的32位和64位
// long double 未规定，和平台实现相关
```

### 字节排序
> 地址一般为占用内存段的最小地址， p++；系统内部是一致，系统之间需要注意转换

#### 大端序列
MSB所在地址是数据的地址即最小地址


#### 小端序列
LSB所在地址是数据的地址即最小地址

#### 示例
```
-10 = -1010B
补码：FFFFFFF6
最高有效字节MSB：FF
最低有效字节LSB：F6

地址    数 据     地址
#100     FF      #103
#101     FF      #102
#102     FF      #101
#103     F6      #100

大端             小端

x = 0x12345678
地址    #100    #101    #102    #103
数据    12      34      56      78      大端
数据    78      56      34      12      小端

```

## 數據運算
> 比较大小：做减法（模运算在加法器中）得到标志信息来判断

### 逻辑运算

#### 布尔代数
起源于 George Boole 的布尔代数：0假、1真； 与、或、非 => 异或（不等价运算）；多位按位计算；真值表；逻辑表达式
实现功能部件的步骤：
1. 真值表描述功能部件的输入和输出之间的关系
2. 根据真值表确定逻辑表达式
3. 由逻辑表达式实现组合逻辑电路

#### 逻辑电路
> 门电路：与门、或门、非门 => 任意逻辑门
1. 组合逻辑电路：没有存储功能，输出仅依赖于当前输入
   1. 移码器
   2. 编码器
   3. 多路选择器mux
   4. 加法器（一位加法器-全加器FA： A、B、Cin => F、Cout）：n位加法器 + 标志信息；不区分类型只认01序列
      1. 整数加/减运算器 -> 算数逻辑部件ALU、乘/除运算电路、浮点运算电路
      2. 标志信息：存储于 程序/状态字寄存器 或 标志寄存器
         1. ZF 零标志 Fi全为0
         2. OF 溢出标志 Coutn 异或 Coutn-1
         3. CF 进/借位标志 Cout 异或 Cin符号位
         4. SF 符号/条件标志 Fn-1
2. 时序逻辑电路：具有存储功能，输出依赖于当前输入和存储单元的当前状态

```c
// 减法 + 标志位 比较大小

无符号数比较：做减法，且 CF = 0 即没有借位，则是大于
带符号数比较：做减法，且 OF = SF 则大于
```

### C中的运算
```c
int x = 9, y = -6, z1, z2;

z1 = x + y
z2 = x - y

// x 的机器数为 x的补码；y 的机器数为 y的补码
// z1 的机器数为 [X + Y]补
// z2 的机器数为 [x - y]补
// x补 = 2^n + x
// 已知 x的补码 则 -x补 = x补 取反 + 1
[x + y]补 = 2^n + (x + y) = 2^n + (2^n + x + y) = x补 + y补 (mod 2^n)
[x - y]补 = x补 + [-y]补 (mod 2^n) = x补 + [y]补取反 + 1
```

#### 运算过程
1. 表达式
2. 指令序列
   1. 汇编指令
   2. 控制器对指令译码，产生控制信号
   3. 将操作数和控制信号传送到运算器进行运算
3. 逻辑运算电路运算


#### 各类运算
1. 高级语言
   1. 整数、浮点数算术运算
   2. 按位、逻辑、移位、位扩展、位截断运算
2. 指令
   1. 定点算术运算
      1. 带符号：取负、符号扩展、加减乘除、算术移位
      2. 无符号：0扩展、加减乘除、逻辑左移、逻辑右移
   2. 定点逻辑运算：与或非
   3. 浮点运算：加减乘除

##### 算术运算
> 无符号整数、带符号整数、浮点数
- +
- -
- *
  - n位乘积计算机中是2n位，但是高级语言中只保留n位；如 int * int = int
  - 二进制的乘可能为负，因为截取 0101 * 0101 = 0001 1001 = 1001 = -111B = -7
  - 保留2n位时乘法指令区分带符号 和 无符号，n位时不区分，但是无法从硬件层面判断溢出
  - 没有溢出标志，只能根据高n位判断：无符号全为0或带符号权威符号位则没有溢出，否则逻辑判断：z/x == y
  - 乘除本质是使用移位和加减
- /
  - 唯一溢出情况：-2^(n-1)/-1 = 2^(n-1) > 2^(n-1) - 1 最大正数；商不会比被除数的绝对值大
  - 整数除法舍入，朝0方向
  - 整除0无法用一个机器数表示，故操作系统抛出异常
  - 除法右移k位，对负数先纠偏， 即被除数加2^k - 1 再右移，然后直接右移
- %

```c
int a = 0x80000000
int b = a / -1   // 优化乘 neg 求补指令：各位取反末位加1 未发生除法溢出
int c = -1
int b = a/c     // Floating point exception，div指令发现发生溢出 # TODO

/*
只使用右移、加法及按位运算实现除32
*/
int div32(int x){
    int fix = (x >> 31) & 0x1F;
    return (x + fix) >> 5;
}
```

###### 浮点数加减
- 阶码上溢
- 阶码下溢
- 尾数左规
- 尾数右规

IEEE 五种异常：
1. 阶码上溢：大于 1111 1110 -> 127
2. 阶码下溢；小于 0000 0001 -> -126
3. 无效运算：非有限数、NaN
4. 除0 -> 1.#INF、-1.#INF
5. 结果不准确：精度问题（中间值加附加位解决，IEEE754规定两个：保护位 + 舍入位）

IEEE 舍入
1. 向正/负无穷方向
2. 向0方向
3. 就近舍入（向最近可表达数舍入）

```c
// 就近舍入
1. 非中间值：谁近向谁 01 -> 00 截断; 11 -> 100 加1
2. 中间值：强迫结果为偶数

// 有效位数
                二进制           十进制
float：           24            6 - 9
double：          53           15 - 17
long double：    113           33 - 36
```

##### 按位运算
> 位串按位运算 - 掩码
- | 或
- & 与
- ~ 取反
- ^ 异或
##### 逻辑运算
- ||
- &&
- !

##### 移位运算
> 提取部分数据 或 乘除2、4、8... 倍
- \>\>
- <<

无符号的左右移都是补0，左移溢出判断：移出的是1则溢出
带符号的左移：高位移出，低位补0，左移溢出判断：移出的位不等于符号位
带符号的右移：低位移出，高位补符，可能发生有效数据丢失

##### 截断和扩展运算
> 类型转换时可能需要
- 扩展：short -> int = 16 -> 32
  - 带符号数是符号位，无符号是0扩展
- 截断：int -> short

## 语句转换与表示(指令)

ISA： Instruction Set Architecture 指令集合体系结构，一种规约，规定如何使用硬件。是对硬件的抽象

1. Intel IA-32指令
2. MIPS
3. ARM

### 指令
> 指令起始地址存储寄存器称为PC，没一个指令都从pc获取
> 初始时 指令 + 数据 都是存储在存储器上，且形式没有区别都是0/1序列
> 指令：IR 指令寄存器中； 数据：GPR 通用寄存器

- 操作码
- 操作数：
  - 源操作数：立即数、寄存器编号、存储地址
  - 目的操作数：寄存器编号、存储地址（与操作数的数据结构有关）

#### 指令执行过程

1. PC取指令
2. 指令译码（ -> 控制信号）
3. 取操作数
4. 指令执行
5. 回写结果
6. 修改PC值为下一条指令起始地址

#### IA32执行过程
1. EIP指令地址 0x80483d4
2. 地址值送到 MAR （Memory Address Register 用于 寄存器和主存数据交换时指定地址）
3. 再将地址值送地址总线
4. 控制器发送读信号到控制总线
5. 将对应地址的值读到数据总线
6. 将对应地址的值存储到MDR（Memory Data Register 用于 寄存器和主存数据交换时临时存储数据）
7. 将对应值送到IR指令寄存器
8. IR高位即操作码送到控制器
9. 控制器堆操作码译码
10. 产生相应控制信号
11. 结果写到MDR
12. 传到数据总线
13. 控制总线将值写到主存
14. EIP增量至下一条循环第1步

### 分类
1. 机器指令：操作码 + 操作数的0/1序列，软硬件交界
   1. 汇编指令：机器指令的汇编符号表示，与机器指令一一对应
2. 微指令：微程序级命令，硬件范畴
3. 伪指令：若干机器指令组成的指令序列，软件范畴


### Gcc示例
```sh
gcc -O1 main.c test.c -o test

gcc -E test.c -o test.i     # 预处理结果
gcc -S test.i -o test.s     # 汇编指令
# 等价于
gcc -S test.c -o test.s     # 汇编指令
#
gcc -c test.s -o test.o

objdump -d test.o           # 反汇编
```

#### 存储器映像
```c
------------
0xC00000000
------------
内核虚存区
------------
用户栈 Stack
------------
     .
共享库区域
     .
------------
堆 malloc generate Heap
------------
读写数据段 .data .bss
------------
只读代码段 .init .text .rodata
-------------
0x08048000
--------------
未使用
```
### IA-32/x64 体系结构
> Intel Architecture 32
> CISC 复杂指令集计算机风格的ISA

8个GPR、1个EFLAGs、PC为EIP、6个段寄存器
可寻址空间4GB（0x0 -> 0xFFFFFFFF）
指令格式变长、操作码变长
#### 支持的数据类型
1. 定点数
   1. b     char        8
   2. w     short       16      有16位发展而来，固16位为一个字
   3. l     int         32
   4. l     long int    32
   5. l     char*       32
   6. s     float       32      单精度
   7. l     double      64      双精度
   8. t     long double 80/96   扩展精度浮点数
2. 浮点数
#### 通用寄存器组织
8位 -> 16位 -> 32位 扩展
Seial   8位     16位    32位    64位            128位
000     AL      AX      EAX     MM0/ST(0)       XMM0
001     CL      CX      ECX     MM1/ST(1)
010     DL      DX      EDX     MM2/ST(2)
011     BL      BX      EBX     MM3/ST(3)
100     AH      SP      ESP     MM4/ST(4)
101     CH      BP      EBP     MM5/ST(5)
110     DH      SI      ESI     MM6/ST(6)
111     BH      DI      EDI     MM7/ST(7)       XMM7
#### 标志寄存器
1. 条件标志
   - OF    溢出标志
   - SF    符号标志
   - ZF    零标志
   - CF    进/借位标志
   - AF    辅助进位标志-BCD码运算
   - PF    奇偶标志
2. 控制标志
   - DF    方向标志-自动变址增减方向
   - IF    中断允许标志
   - TF    陷阱标志-是否是单步跟踪状态debug时
#### 寻址方式
> 根据指令给的信息的到操作数或操作数地址

1. 指令中：立即据
2. 寄存器中：寄存器寻找
3. 存储器中：存储器操作数，按字节编址，如何得到线性地址； SR段基址 + 其他偏移地址
   1. 位移                     LA = SR + A
   2. 基址寻址                 LA = SR + B
   3. 基址 + 位移              LA = SR + B + A
   4. 比例变址 + 位移           LA = SR + I*S + A          单层数组寻址
   5. 基址 + 变址 + 位移        LA = SR + B + I + A
   6. 基址 + 比例变址 + 位移     LA = SR + B + I*S + A      嵌套数组寻址
   7. 相对寻址                  LA = PC + A

LA：线性地址（存储空间中的地址）
SR：段寄存器
PC：程序计数器
A：指令中给定地址段的位移量
B：基址寄存器
I：变址寄存器
S：比例系数

存储器操作数的寻址方式与微处理器工作模式：
1. 实模式
   1. 基本用不到，用于兼容 8086/8088 处理器兼容2
   2. 20位地址： CS<<4 + IP
2. 保护模式
   1. 虚拟存储
   2. 2^32B = 4GB 内存，32位线性地址（段基址 + 段内偏移量）

段寄存器：
1. 代码段 CS
2. 堆栈段 SS
3. 数据段 DS

#### 常用指令

##### 传送指令

数据传送
- mov
  - movb
  - movw
  - movl
- movs      符号扩展传送
  - movsbw
  - movswl
- movz      零扩展传送
  - movzwl
  - movzbl
- xchg      数据交换
- push/pop
  - pushl
  - pushw

地址传送（指针传递）
- lea       IO端口与寄存器
  - leal

标志传送 EFLAG 入栈和接收栈值
- pushf
- popf

输入输出
- in/out

##### 定点运算指令
> 查阅

##### 逻辑运算和移位指令
> 查阅

##### 条件转移指令
> 查阅，根据标志位作为条件

Jcc
cc 为条件码
  - c / nc    根据 CF = 1/0
  - e / ne     ZF = 1/0
  - s / ns     SF = 1/0
  - o / no     OF = 1/0
以及组合标志位作为条件码
  - jbe     无符号比较
  - jle     带符号比较

## 函數條用轉換表示
> 基于IA32

执行步骤：P=调用者、Q=被调用者
1. P将入口参数-实参放到Q能访问的地方
2. P保存返回地址到栈、将控制权转移到Q - CALL
3. Q保存P的现场（通用寄存器内容），并为自己的非静态局部变量分配空间
4. 执行Q的过程体
5. Q恢复P的现场，释放局部变量空间
6. Q取回返回地址，并将控制转移到P - RET

### 寄存器使用约定
1. EAX、EDX、ECX 由P保存并恢复；Q直接使用
2. EBX、ESI、EDI 由Q保存并恢复
3. EBP 帧指针寄存器-栈底部、ESP 栈指针寄存器-栈顶部


三个过程
1. 准备阶段
   1. 形成新栈底 push
   2. 生成栈帧 - esp下移
   3. 保存现场
2. 过程（函数体）
   1. 分配局部变量，并赋值
   2. 具体处理逻辑：参数、CALL（保存返回地址下一条指令地址到栈顶 并将被调用地址保存进eip转换调用函数）
   3. 返回值保存入（整型->EAX、浮点型->ST[0]）
3. 结束阶段
   1. 退栈
   2. 保存返回值到eax
   3. 取返回地址返回 RET（将返回地址保存进eip）
```c
EBP - ESP : stack frame

--------------------- 0x00000000 高地址
调用过程栈帧
保存寄存器 EAX、EDX、ECX
--------------------- EBP1 - P
调用这P保存寄存器
---------------------
   实参n
    .
   实参1
---------------------
返回地址                              >>>>>>> 返回点
--------------------- ESP1 - P
EBP1 - P
--------------------- EBP2 - Q
被调用过程栈帧
保存寄存器 EBX、ESI、EDI
---------------------
非静态局部变量
--------------------- ESP2 - Q
--------------------- 0xFFFFFFFF
```

### 每个函数/过程的开始语句 - 准备栈帧
```asm
pushl %ebp        # 保存旧的 ebp 值
movl  %esp, %ebp  # 将esp的值赋给ebp，形成新的栈，栈底为旧的ebp值
subl  $n, %esp    # 申请栈空间
...
call funcname     # 将返回地址压入栈中，返回时取出放入 eip 寄存器
...
ret
```

## x86-64

### 参数传递
> 不同于IA-32使用栈：RBP + n； 使用通用寄存器
1. RDI 对应宽度 - 第一个参数  EDI   DI   DIL
2. RSI 对应宽度 - 第二个参数
3. RDX 对应宽度 - 第三个参数
4. RCX 对应宽度 - 第四个参数
5. R8 对应宽度 = 第五个参数   R8D   R8W   R8B
6. R9 对应宽度 - 第六个参数
多于6个参数时从右至左逆序依次压入栈，基本类型则分配 8 字节（IA-32分配 4 字节）

返回地址 存放在 栈 中：R[esp] = R[esp] - 8
返回值：RAX
浮点数送到 XMM0 寄存器

### 传送指令
b - 8位
w - 16位
l - 32位
q - 64位

- movzbq 、 movzwq : 将8/16位的源操作数0扩展成64位
- movsbq 、movswwq : 将8/16位的源操作数符号扩展成64位
= movl = movzlq ：将32位扩展成64位(低32位 或 0扩展成64位)
-pushq / popq

### 类型转换
destType y = (destType) x
1. char -> long:  movsbq
2. int -> long: movslq
3. long -> long: movq
4. long -> int: movl = movslq
5. unsigned int -> unsigned long: movl = movzlq
6. unsigned long -> unsigned int: movl = movzlq
7. unsigned char -> unsigned long: movzbq

### 算术逻辑指令
1. addb/w/l/q
2. sub
3. inc
4. dec
5. imul 带符号乘
6. mul 无符号乘
7. or
8. sal  左移
9. leaq 有效地址加载到64位寄存器

## 鏈接和加載
> Linux ELF 格式； 文本 -> 二进制机器指令序列

1. 高级语言文本 .c
|   - 预处理   gcc -E hello.c -o hello.i
2. 高级语言预处理文本 .i
|   - 编译     gcc -S hello.i/c -o hello.s     词法分析、语法分析、语义分析并优化
3. 汇编语言文本 .s
|   - 汇编     gcc -c hello.s/c -o hello.o   || as heello.s -o hello.o
4. 二进制可重定位目标程序 .o
|   - 链接多个 gcc -static -o target main.o pkg.o  || ld ...      确定引用符合的地址值
5. 二进制可执行目标程序 [.exe]


### 可执行文件磁盘存储映像
```c
-------------------------- 0 虚拟地址存储空间
      ELF头
--------------------------
   程序（段）头表
--------------------------
      .init 节
--------------------------
      .text 节               只读代码段
--------------------------
      .rodata 节
--------------------------
      .data 节
--------------------------   读写数据段
      .bss 节
--------------------------
      .symtab 节
--------------------------
      .debug 节
--------------------------
      .line 节
--------------------------
      .strtab 节
--------------------------
```

### <span id="executable_storage_snapshot">可执行文件链接虚拟存储空间映像</span>

```c
-------------------------- 高地址
内核虚存区（1GB）
-------------------------- %RBP
   用户栈User Stack
-------------------------- %RSP

   Free Memory

--------------------------
   共享库区域
--------------------------

   Free Memory

--------------------------
   堆 heap
--------------------------
读写数据段（.data .bss）
--------------------------
只读代码段（ELF 程序头表 .init .text .rodata）
-------------------------- 0x8048000 向上
      未使用
-------------------------- 低地址
```

### 链接
> 符号引用、代码模块化；链接即是确定符号在实际机器代码中的行号和位置
> 代码、数据

1. 符号解析 - 符号引用关系确定
2. 合并相关 .0 文件
3. 符号定义值即地址确定
4. 引用符号的地方使用新地址替换

位置解析 + 重定位（虚拟地址空间之中）

#### 目标文件格式
> 包含目标代码的文件；开头的十六字节的标识信息的前4个字节为魔数

1. COM格式 - DOS操作系统
2. COFF格式 - System V UNIX
3. PE格式 - Windows系统 基于 COFF Portable Executable
4. ELF格式 - Linux系统 基于 COFF Executable and Linked Format

##### ELF
> ==>  可被链接生成可执行或共享目标文件（静态链接库由若干可重定位目标文件组成）
```shell
readelf -h main.o/a.out    # 查看ELF表
readelf -S main.o/a.out    # 查看节头表
readelf -l a.out           # 查看程序头表（段头表）
```

1. 代码  .text
2. 数据  .data已初始化的全局变量或局部静态变量    .bss未初始化的全局变量和局部静态变量
3. 可重定位信息(指出哪些符号需要重定位) 或  已基于虚拟地址重定位
4. Linux .o    Windows .obj  或   .out       .exe

###### 链接视图
> 若干节
```c
----------------------------
         ELF头
----------------------------
       程序头表（可选）
----------------------------
         节1   .text
----------------------------
         ...   .rodata -> .data -> .bss -> .symtab -> .rel.text -> .rel.data -> .debug -> .strtab
----------------------------
         节n   .line
----------------------------
       节头表  Section Header Table
----------------------------

1. ELF      包含16字节标识信息、文件类型（.o .exec .so）、机器类型（x868-64）、节头表的偏移、节头表的表项大小以及个数；区分32位和64位版本
2. .text    编译后的代码部分
3. .rodata  只读数据，如 print格式串、switch跳转表等
4. .data    已初始化的全局变量或局部静态变量
5. .bss     Block Started by Symbol 磁盘不占用空间，做区分，但是内存存储需要预留；在节头表中说明该预留多大空间
            ------------------- 上面都是需要映射到内存的节
6. .symtab  符号表节，存放函数名和全局变量，不包含局部变量
7. .rel.text   .text节的重定位信息，用于修改代码节中的地址信息
8. .rel.data   .data节的重定位信息
9. .debug      调试用符号表 gcc -g
10. strtab     包含 symtab 和 debug 节中符号及节名
11. sht        节头表，每个节的节名、偏移和大小
            ------------------- 链接时使用
```

魔数 文件开头几个字节，用于确定文件类型或格式
1. a.out： 01H 07H
2. PE：4DH 5AH
3. ELF: 7f 45 4c 46

###### 执行视图
```c
----------------------------
         ELF头 (e_entry第一条指令地址)
----------------------------
       程序头表（段头表）
----------------------------
         .init节
----------------------------
         .text
----------------------------
         .rodata
----------------------------  只读段
         .data
----------------------------
         .bss
----------------------------  读写段
         .symtab
----------------------------
         .debug
----------------------------
         .strtab
----------------------------
         .line
----------------------------
       节头表（可选）
----------------------------  无需装入到存储空间

1. ELF         + 多了一个e_entry表明程序执行时得到第一条指令地址
2. 程序头表     + 又称 段头表，Segment Header Table 是一个结构数组（映射到存储空间的段，描述了节和段的关系）
3. .init       + 定义 _init，用于可执行目标文件开始执行时的初始化工作
4. rel文件     - 不需要rel文件，已经重定位
```
[存储映像](#executable_storage_snapshot)

#### 可重定位目标文件
> .o
与 .c 一对一，文件的代码和数据地址都是从0开始

#### 可执行目标文件
> .out    .exe
代码和数据可以直接复制到内存并被执行，地址位虚拟空间的地址

#### 共享库文件
> .so    .dll
特殊的可重定位目标文件（若干可重定位目标文件），能在装入或运行的时候被装入到内存并自动被链接到可执行文件

##### 动态链接库

##### 静态链接库

#### 链接过程

##### 符号解析

###### 符号和符号表

###### 符号解析和静态链接

##### 重定位

###### 符号的重定位

###### 文件加载和动态链接

## 程序執行

## 層次結構存儲系統

## 異常和中斷處理

## 輸入輸出IO
